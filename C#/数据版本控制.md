###### 乐观锁-----版本控制

> 一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

``读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 
交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 
版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。 
对于上面修改用户帐户信息的例子而言，假设数据库中帐户信息表中有一个 
version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。 
1 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50 
（ $100-$50 ）。 
2 在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ version=1 ），并 
从其帐户余额中扣除 $20 （ $100-$20 ）。 
3 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣 
除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大 
于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。 
4 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数 
据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的 
数据版本号为 2 ，数据库记录当前版本(再查一遍该记录)也为 2 ，不满足 “ 提交版本必须大于记 
录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。 
这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作 
员 A 的操作结果的可能。 
从上面的例子可以看出，乐观锁机制避免了长事务中的数据库加锁开销（操作员 A 
和操作员 B 操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 
统整体性能表现。 ``

###### 悲观锁

> 悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自 
> 外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定 
> 状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能 
> 真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 
> 统不会修改数据）。 

​	`` 不同的情况使用不同的锁，效率会提升很多``

